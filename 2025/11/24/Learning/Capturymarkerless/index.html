<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="无标记动作捕捉使用及插件接入CapturyLiveLink_5.2
API文档
官方教程
172.26.7.51
Blueprint Runtime Error: “Attempted to access index -1 from array ARkit Value of length 0!”. ">
    

    <!--Author-->
    
        <meta name="author" content="Eugene Hsuan">
    

    <!--Open Graph Title-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Eugene&#39;s Page"/>

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>Eugene&#39;s Page</title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/css/table.css">

    
<link rel="stylesheet" href="/css/image-zoom.css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Mermaid Support -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>

    <!-- Google Analytics -->
    


    <!--Favicon-->
    
        <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/img/favicon.ico" type="image/x-icon">
    

    
        <link rel="alternate" type="application/atom+xml" title="Eugene&#39;s Page" href="/atom.xml">
    
        <link rel="alternate" type="application/rss+xml" title="Eugene&#39;s Page" href="/rss.xml">
    

<meta name="generator" content="Hexo 7.3.0"></head>


<body class="layout-post path-2025-11-24-Learning-Capturymarkerless-">

<!-- Menu -->
<!-- Navigation -->
<header>
    <div class="logo">
        <a href="/">Eugene's Page</a>
        <div class="subtitle"></div>
        <div class="description"></div>
    </div><!-- end logo -->

    <div id="menu_icon"></div>
    <nav>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives">Archives</a>
            </li>
            
            <li>
                <a href="/about">About</a>
            </li>
            
        </ul>
    </nav><!-- end navigation menu -->

    <div class="footer clearfix">
        <ul class="social clearfix">
            
                <li><a href="https://space.bilibili.com/29291963" class="behance" target="_blank" data-title="Bilibili"></a></li>
            
            
                <li><a href="https://www.instagram.com/yu_chinghsuan?igsh=Mm54ajloc3c1NW5m&utm_source=qr" class="instagram" target="_blank" data-title="Instagram"></a></li>
            
            
                <li><a href="https://www.douban.com/people/Youdrew_Xuan/" class="dribble" target="_blank" data-title="Douban"></a></li>
            
            
                <li><a href="mailto:youdrewxuan@icloud.com" class="google" target="_blank" data-title="Email"></a></li>
            
            
                <li><a href="/rss.xml" class="rss" target="_blank" data-title="RSS"></a></li>
            
        </ul><!-- end social -->

        <div class="rights">
            <p>Copyright © 2025 Eugene Hsuan</p>
            <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p>
            <p>Modified based on <a href="https://github.com/klugjo/hexo-theme-magnetic" target="_blank">Magnetic</a> theme</p>
        </div><!-- end rights -->
    </div ><!-- end footer -->
</header><!-- end header -->


<!-- Main Content -->
<section class="main clearfix">

    <section class="top" style="background: url('/img/default_cover_detail.jpg');">
        <div class="wrapper content_header clearfix">
            

<div class="work_nav">

    <ul class="btn clearfix">
        
        <li><a href="/2025/11/24/Learning/CodeReview/" class="previous" data-title="Untitled"></a></li>
        
        <li><a href="/" class="grid" data-title="Portfolio"></a></li>
        
        <li><a href="/2025/11/21/Notes/Unreal%20RemoteControl%20Note/" class="next" data-title="Unreal RemoteCont..."></a></li>
        
    </ul>

</div><!-- end work_nav -->
            <h1 class="title">Untitled</h1>
        </div>
    </section><!-- end top -->

    <section class="wrapper">
        <div class="content">

            <!-- Gallery -->
            

            <!-- Content -->
            <h1 id="无标记动作捕捉使用及插件接入"><a href="#无标记动作捕捉使用及插件接入" class="headerlink" title="无标记动作捕捉使用及插件接入"></a>无标记动作捕捉使用及插件接入</h1><p><a target="_blank" rel="noopener" href="https://www.fab.com/listings/69ee923d-1a3a-42be-8f2a-9924b6e7b79a">CapturyLiveLink</a>_5.2</p>
<p><a target="_blank" rel="noopener" href="http://doc.captury.com/python.html">API文档</a></p>
<p><a target="_blank" rel="noopener" href="http://doc.captury.com/CapturyLive/index.html#overview">官方教程</a></p>
<p>172.26.7.51</p>
<p>Blueprint Runtime Error: “Attempted to access index -1 from array ARkit Value of length 0!”. Node:  Set ARkit Head Rotation Graph:  EventGraph Function:  Execute Ubergraph ABP Main Last ZTY Body Blueprint:  ABP_Main_LastZTY_Body<br>Blueprint Runtime Error: “Attempted to access index -1 from array ARkit Value of length 0!”. Node:  Set ARkit Head Rotation Graph:  EventGraph Function:  Execute Ubergraph ABP Main Last ZTY Body Blueprint:  ABP_Main_LastZTY_Body<br>Blueprint Runtime Error: “Attempted to access index -1 from array ARkit Value of length 0!”. Node:  Set ARkit Head Rotation Graph:  EventGraph Function:  Execute Ubergraph ABP Main Last ZTY Body Blueprint:  ABP_Main_LastZTY_Body<br>Blueprint Runtime Error: “Attempted to access index -1 from array ARkit Value of length 0!”. Node:  Set headRoll Graph:  EventGraph Function:  Execute Ubergraph ABP Main Last ZTY Body Blueprint:  ABP_Main_LastZTY_Body</p>
<p>我的Livelink人物动捕数据接入之后，人物没有反应。</p>
<h2 id="Captury原始插件底层sock阻塞问题"><a href="#Captury原始插件底层sock阻塞问题" class="headerlink" title="Captury原始插件底层sock阻塞问题"></a>Captury原始插件底层sock阻塞问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在插件接入的时候（插件已经完成了接入，数据已经连通），但遇到一个问题：</p>
<p>用户反馈，如果要从Captury信号源切换到别的信号源的时候，会发生卡顿的现象。</p>
<p>卡顿时间在固定的20s左右。</p>
<p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205150209762.png" alt="image-20251205150209762"><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205150637519.png" alt="image-20251205150637519"></p>
<p>且这个问题仅仅发生在<u>Captury信号源没连接上的状态</u>中。如果信号连接上了，切换这个操作不会发生卡顿。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>这个操作背后的逻辑是，用户切到别的信号源，我会销毁掉已经生成的CapturyLivelink，确保Livelink信号池子干净。</p>
<p>同时，刷新信号的按钮也会出现这个问题，因为刷新的时候，我背后做的操作是：先删除掉老的CapturyLivelink，然后在创建新的连接数据。</p>
<p>且为了防止出现底层数据竞争的问题。我永远只允许一个CapturyLivelink信号源出现。</p>
<p>所以，在切到别的信号源的时候，我永远会销毁掉老的信号源。而问题就发生在删除老的信号源上面，只要一旦要销毁没有连上的老的信号源，就会发生这个20s左右的卡顿。</p>
<p>可是为什么是“没有连接上”才会发生卡顿，而正常情况下不会呢？<u>暂时不得而知。所以暂时推断问题应该在底层断连逻辑这一块。</u></p>
<p>通过Unreal Insight发现，在执行了Captury_disconnect操作之后。整个系统陷入等待，时间会有三十多秒。</p>
<p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205153031066.png" alt="image-20251205153031066"></p>
<p>所以这里确定了是断连操作造成了这个卡顿。</p>
<p>然后 我在卡顿的（这十几秒里）时候，暂停了IDE，看看当前Game停在了哪里，Game停在了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(receiveThread, INFINITE);</span><br></pre></td></tr></table></figure>

<p>这一句话。这句话是我前几天加的，考虑到两个CapturyLivelink会出现多线程的问题，底层占用会导致崩溃，所以我写了需要等待底下工作的线程真正地退出，才算完成退出操作。</p>
<p>所以我意识到了，问题应该是出在了receiveThread线程的loop里。</p>
<p>于是开始在整个链路上打Log寻找罪魁祸首看看是哪个接口造成的。<br>并且在链路中添加更多地退出机制（stopReceiving、bExternalShutdownRequested），看看能否去掉卡顿。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="function">DWORD <span class="title">RemoteCaptury::receiveLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">RemoteCaptury::receiveLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> handshaking = !handshakeFinished;</span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;01 starting receive loop %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="comment">//log(&quot;starting receive loop\n&quot;);</span></span><br><span class="line">    <span class="keyword">while</span> (!stopReceiving</span><br><span class="line">       &amp;&amp; !bExternalShutdownRequested </span><br><span class="line">       &amp;&amp; (!handshaking || !handshakeFinished)) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;02 receive loop iteration %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">receive</span>(sock)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sock == <span class="number">-1</span></span><br><span class="line">             &amp;&amp; !stopReceiving</span><br><span class="line">             &amp;&amp; !bExternalShutdownRequested )</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="built_in">deleteActors</span>();</span><br><span class="line">                cameras.<span class="built_in">clear</span>();</span><br><span class="line">                numCameras = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;03 socket closed, reconnecting %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">                <span class="keyword">if</span> (isStreamThreadRunning) &#123;</span><br><span class="line">                   stopStreamThread = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">                   <span class="built_in">WaitForSingleObject</span>(streamThread, <span class="number">1000</span>);</span><br><span class="line">                   <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                   <span class="type">void</span>* retVal;</span><br><span class="line">                   <span class="built_in">pthread_join</span>(streamThread, &amp;retVal);</span><br><span class="line">                   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;03 a socket closed, reconnecting %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;04-1 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">             <span class="keyword">while</span> (!stopReceiving) &#123;</span><br><span class="line">                <span class="comment">// 停止重连</span></span><br><span class="line">                sock = <span class="built_in">openTcpSocket</span>();</span><br><span class="line">                <span class="comment">//UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;04-2 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">                <span class="keyword">if</span> (sock != <span class="number">-1</span>)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">sleepMicroSeconds</span>(<span class="number">1000</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;04-3 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (streamWhat != CAPTURY_STREAM_NOTHING)</span><br><span class="line">                <span class="built_in">Captury_startStreamingImagesAndAngles</span>(<span class="keyword">this</span>, streamWhat, streamCamera, (<span class="type">int</span>)streamAngles.<span class="built_in">size</span>(), streamAngles.<span class="built_in">data</span>());</span><br><span class="line">                <span class="comment">//UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;05 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">             </span><br><span class="line">             handshaking = <span class="literal">false</span>; <span class="comment">// this is a lie but makes it go into the normal loop</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//log(&quot;stopping receive loop\n&quot;);</span></span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;06 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果Log查出问题了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Display LogCaptury CapturyLiveLink: request shutdown</span><br><span class="line">Warning LogCapturyRemote Captury_stopStreaming() called</span><br><span class="line">Warning LogCapturyRemote Captury_disconnect() called</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() called</span><br><span class="line"></span><br><span class="line">Warning LogCapturyRemote 01 starting receive loop 267 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote 02 receive loop iteration 268 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote 03 socket closed, reconnecting 269 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote 03 a socket closed, reconnecting 270 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote Captury_disconnect() called</span><br><span class="line">Warning LogCapturyRemote 04-1 271 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() called</span><br><span class="line">Warning LogCapturyRemote openTcpSocket() 01 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote openTcpSocket() 02 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote openTcpSocket() 03 2025.12.04-18.57.03</span><br><span class="line">Display LogCaptury CapturyLiveLink: request shutdown</span><br><span class="line">Warning LogCapturyRemote Captury_stopStreaming() called</span><br><span class="line">Warning LogCapturyRemote Captury_disconnect() called</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() called</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() **: waiting for receiveThread 2025.12.04-18.57.05</span><br><span class="line">Warning LogCapturyRemote 04-2 272 2025.12.04-18.57.24</span><br><span class="line">Warning LogCapturyRemote 04-3 273 2025.12.04-18.57.24</span><br><span class="line">Warning LogCapturyRemote 06 274 2025.12.04-18.57.24</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() **: receiveThread finished 2025.12.04-18.57.24</span><br><span class="line"></span><br><span class="line">Display LogCaptury CapturyLiveLink: request shutdown</span><br><span class="line">Warning LogCapturyRemote Captury_stopStreaming() called</span><br><span class="line">Warning LogCapturyRemote Captury_disconnect() called</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() called</span><br></pre></td></tr></table></figure>

<p>其中openTcpSocket()+数字的部分以及RemoteCaptury::disconnect() 是我游戏线程。</p>
<p>当我下达关机指令的时候，remote线程卡在了04-1和04-2之间。并且remote线程是活的。所以大家都在等remote线程。</p>
<p>而这两个Log之间夹的函数就是sock &#x3D; openTcpSocket();</p>
<p>这个函数的作用是：创建一个 TCP，套接字并尝试与远程地址建立连接。</p>
<p>下面是原始的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">RemoteCaptury::openTcpSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;opening TCP socket\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SOCKET sok = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sok == <span class="number">-1</span>)</span><br><span class="line">       <span class="keyword">return</span> (SOCKET)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localAddress.sin_port != <span class="number">0</span> &amp;&amp; <span class="built_in">bind</span>(sok, (sockaddr*) &amp;localAddress, <span class="built_in">sizeof</span>(localAddress)) != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">closesocket</span>(sok);</span><br><span class="line">       <span class="keyword">return</span> (SOCKET)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">connect</span>(sok, (sockaddr*) &amp;remoteAddress, <span class="built_in">sizeof</span>(remoteAddress)) != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">closesocket</span>(sok);</span><br><span class="line">       <span class="keyword">return</span> (SOCKET)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set read timeout</span></span><br><span class="line">    <span class="built_in">setSocketTimeout</span>(sok, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIN32</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;connected to %s:%d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;remoteAddress.sin_addr, buf, <span class="number">100</span>), <span class="built_in">ntohs</span>(remoteAddress.sin_port));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过加Log发现，函数卡在了。</p>
<p><code>if (::connect(sok, (sockaddr*) &amp;remoteAddress, sizeof(remoteAddress)) != 0) </code></p>
<p>这个if判断里面，而这个接口是windows的sock接口。ok，至此，已经找到罪魁祸首了。</p>
<h3 id="底层逻辑阐述"><a href="#底层逻辑阐述" class="headerlink" title="底层逻辑阐述"></a>底层逻辑阐述</h3><p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205123239125.png" alt="image-20251205123239125"></p>
<p>这一节想解释清楚两件事：</p>
<ol>
<li><strong>为什么阻塞式 <code>connect</code> 会在「没连上」的时候卡住几十秒</strong>；</li>
<li>这个行为和阻塞 &#x2F; 非阻塞、缓冲区、IO 多路复用之间的关系。</li>
</ol>
<h4 id="1-阻塞-connect-为什么会卡很久"><a href="#1-阻塞-connect-为什么会卡很久" class="headerlink" title="1. 阻塞 connect 为什么会卡很久"></a>1. 阻塞 <code>connect</code> 为什么会卡很久</h4><p>原始代码里的 <code>openTcpSocket</code> 使用的是<strong>阻塞 socket + 阻塞 <code>connect</code></strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sok = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (::<span class="built_in">connect</span>(sok, (sockaddr*)&amp;remoteAddress, <span class="built_in">sizeof</span>(remoteAddress)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(sok);</span><br><span class="line">        <span class="keyword">return</span> (SOCKET)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在阻塞模式下：</p>
<ul>
<li><code>connect</code> 会进入内核，等待 TCP 三次握手完成或者失败；</li>
<li>如果远端服务没开 &#x2F; IP 不可达 &#x2F; 包被丢弃，系统会按自己的重试策略不断发 SYN、等待回应；</li>
<li>在这段时间里，调用 <code>connect</code> 的线程会一直被挂起，直到<strong>内核判定“连接失败”并超时返回</strong>；</li>
<li>这个超时通常是几十秒级（你实际观测到的就是 ~20s）。</li>
</ul>
<p>结合上面的 receiveLoop，可以看到：</p>
<ul>
<li><code>receiveLoop</code> 在重连时会反复调用 <code>sock = openTcpSocket();</code>；</li>
<li>当 Captury 端没开的时候，每次 <code>openTcpSocket()</code> 都会在 <code>connect</code> 内部卡到系统超时；</li>
<li>你的 <code>disconnect()</code> 又在 <code>WaitForSingleObject(receiveThread, INFINITE);</code> 等这个线程自然退出；</li>
<li>于是 Game 线程就被这一条阻塞式 <code>connect</code> 间接拖住了几十秒。</li>
</ul>
<p>也就是说，这里并不是逻辑死锁，而是<strong>单纯被内核的阻塞连接等待住了</strong>。</p>
<h4 id="2-阻塞-I-O、缓冲区和-IO-多路复用问题（扩展）"><a href="#2-阻塞-I-O、缓冲区和-IO-多路复用问题（扩展）" class="headerlink" title="2. 阻塞 I&#x2F;O、缓冲区和 IO 多路复用问题（扩展）"></a>2. 阻塞 I&#x2F;O、缓冲区和 IO 多路复用问题（扩展）</h4><p>阻塞的问题不只出现在 <code>connect</code>，也同样存在于 <code>read</code> &#x2F; <code>write</code>（WinSock 里的 <code>recv</code> &#x2F; <code>send</code>）：</p>
<ul>
<li>阻塞模式下：<ul>
<li><code>recv</code> 在缓冲区“没数据可读”时会一直等；</li>
<li><code>send</code> 在发送缓冲区满时会一直等；</li>
<li>线程就挂在这些系统调用里，直到有数据或有空位。</li>
</ul>
</li>
</ul>
<p>这几张图，其实就是描述：应用线程在访问一个<strong>内核缓冲区</strong>——</p>
<img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205142827661.png" alt="image-20251205142827661" style="zoom:25%;" />

<ul>
<li>读的时候：如果缓冲区里<strong>暂时没数据</strong>，阻塞 <code>read/recv</code> 会卡住线程；</li>
<li>写的时候：如果缓冲区已经<strong>写满</strong>，阻塞 <code>write/send</code> 会卡在那儿等内核把旧数据发走。</li>
</ul>
<img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205144248299.png" alt="image-20251205144248299" style="zoom:25%;" />

<img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205144319439.png" alt="image-20251205144319439" style="zoom:25%;" />

<p>在“阻塞模型”下（原来的代码），如果网络线程直接在这些调用上阻塞：</p>
<ul>
<li><p>它就<strong>没法及时响应退出信号</strong>（<code>stopReceiving</code> &#x2F; <code>bExternalShutdownRequested</code> 等）；</p>
</li>
<li><p>像 <code>disconnect()</code> 这种需要“等待线程正常退出”的逻辑，也都会被一起拖住。比如下下面这张图片，多线程的阻塞模式，会在有大量连接调用的时候，开辟多个线程，去做连接，一个服务一个连接，这个服务断掉了这个，这个线程占用才结束，这是一个很古早的调用方式，因为线程其实也是很珍贵的资源，一台电脑总共也没几个线程。（回到我的项目里，因为我只允许运行一个Captury线程，而且Game线程会等这个线程，所以整个游戏卡着。当然我这么做也有别的考量）</p>
<img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205191914919.png" alt="image-20251205191914919" style="zoom:25%;" /></li>
</ul>
<p> <strong>IO 多路复用（<code>select</code> &#x2F; <code>poll</code> &#x2F; <code>epoll</code> &#x2F; <code>WSAPoll</code>）</strong>，本质上是在做一件事：</p>
<ul>
<li>不把线程挂死在 <code>read/write/connect</code> 上，而是：<ul>
<li>先在一个“描述符集合”上等「可读 &#x2F; 可写 &#x2F; 异常」事件；</li>
<li>只有当内核告诉你“这个 fd 已经准备好”时，再真正去 <code>read/recv</code> 或 <code>write/send</code>；</li>
<li>这个等待可以设置自定义超时（例如 10ms、100ms、1s），并在每次醒来时检查退出条件。</li>
</ul>
</li>
</ul>
<h4 id="3-非阻塞-ioctlsocket-在这里的作用"><a href="#3-非阻塞-ioctlsocket-在这里的作用" class="headerlink" title="3. 非阻塞 + ioctlsocket 在这里的作用"></a>3. 非阻塞 + <code>ioctlsocket</code> 在这里的作用</h4><p><code>ioctlsocket(sok, FIONBIO, &amp;NonBlocking)</code> 就是把 socket 从“阻塞模式”切换到“非阻塞模式”。</p>
<p>在非阻塞模式下：</p>
<ul>
<li><code>connect</code> 不再把线程挂死，而是：<ul>
<li>立刻返回一个错误码（例如 <code>WSAEWOULDBLOCK / WSAEINPROGRESS</code>），表示“连接还在进行中”；</li>
<li>后续由你自己用 <code>select</code> &#x2F; <code>WSAPoll</code> 等来轮询「这条连接是否已经成功&#x2F;失败」，并且可以<strong>自己控制最大等待时间</strong>；</li>
</ul>
</li>
<li><code>read/recv</code>、<code>write/send</code> 遇到没数据 &#x2F; 缓冲区满时，也会立刻返回 <code>EWOULDBLOCK</code>，由你的逻辑决定下一步怎么做，而不是直接卡死线程。</li>
</ul>
<p>总结一下这一节：</p>
<ul>
<li><strong>根因</strong>：阻塞 <code>connect</code> 在目标不可达时会触发系统级长超时，线程被内核挂起几十秒；</li>
<li><strong>放大器</strong>：你的 <code>receiveLoop</code> 在重连路径里频繁调用 <code>openTcpSocket()</code>，而 <code>disconnect()</code> 又必须等线程退出；</li>
<li><strong>改成非阻塞的目的</strong>：用 <code>ioctlsocket(FIONBIO)</code> + <code>select</code> 自己控制等待时长和退出时机，把“不可控的 20s 超时”变成“可控的 1s 以内失败”，从而让 <code>disconnect()</code> 快速返回。</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205123239125.png" alt="image-20251205123239125"></p>
<p>非阻塞是“通过修改套接字模式”实现的——代码在 socket() 之后、connect() 之前把套接字设为非阻塞，因此 connect() 就是在非阻塞模式下执行的；连接完成后再把套接字恢复成阻塞。</p>
<ul>
<li>所以其实我这个修改后的代码，并不是完全非阻塞的。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>因为这里调用了底层 WinSock 的 connect。<br>它是 Windows 提供的系统调用，没办法在内部加条件判断。</p>
<p>我们只能：</p>
<ul>
<li>要么换一种调用方式（非阻塞 + 自己用 select&#x2F;WSAPoll 控制超时）；</li>
<li>要么在调用 connect 前后做逻辑，比如提前检测 stopReceiving，或者调用后在另一个线程里强制 closesocket。</li>
</ul>
<p>但这个方案不是很问题，需要维护另外一个线程来关闭这个线程。听起来就很麻烦。所以我用前者，来改造一个非阻塞的sock。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">RemoteCaptury::openTcpSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 01 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="comment">// 函数通过调用 socket 创建一个套接字。如果创建失败（返回 INVALID_SOCKET），函数直接返回错误状态</span></span><br><span class="line">    SOCKET sok = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sok == INVALID_SOCKET)</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 02 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="comment">// 如果 localAddress 的端口号不为 0，函数会尝试将套接字绑定到指定的本地地址。如果绑定失败，同样关闭套接字并返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (localAddress.sin_port != <span class="number">0</span> &amp;&amp; <span class="built_in">bind</span>(sok, (sockaddr*)&amp;localAddress, <span class="built_in">sizeof</span>(localAddress)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(sok);</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 03 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="comment">// 1. 先设成非阻塞</span></span><br><span class="line">    u_long NonBlocking = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctlsocket</span>(sok, FIONBIO, &amp;NonBlocking) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(sok);</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尝试发起 connect</span></span><br><span class="line">    <span class="type">int</span> ConnectResult = ::<span class="built_in">connect</span>(sok, (sockaddr*)&amp;remoteAddress, <span class="built_in">sizeof</span>(remoteAddress));</span><br><span class="line">    <span class="keyword">if</span> (ConnectResult == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="type">int</span> Err = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">if</span> (Err != WSAEWOULDBLOCK &amp;&amp; Err != WSAEINPROGRESS &amp;&amp; Err != WSAEALREADY) &#123;</span><br><span class="line">            <span class="comment">// 真错误，直接失败</span></span><br><span class="line">            <span class="built_in">closesocket</span>(sok);</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 连接正在进行中，用 select 等待一小段时间</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MaxWaitMillis = <span class="number">1000</span>; <span class="comment">// 1 秒上限</span></span><br><span class="line">        fd_set WriteSet;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;WriteSet);</span><br><span class="line">        <span class="built_in">FD_SET</span>(sok, &amp;WriteSet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> Tv;</span><br><span class="line">        Tv.tv_sec = MaxWaitMillis / <span class="number">1000</span>;</span><br><span class="line">        Tv.tv_usec = (MaxWaitMillis % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> Sel = <span class="built_in">select</span>((<span class="type">int</span>)(sok + <span class="number">1</span>), <span class="literal">nullptr</span>, &amp;WriteSet, <span class="literal">nullptr</span>, &amp;Tv);</span><br><span class="line">        <span class="keyword">if</span> (Sel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 超时或 select 出错，都当失败</span></span><br><span class="line">            <span class="built_in">closesocket</span>(sok);</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. select 说 socket 可写了，用 SO_ERROR 再确认一次</span></span><br><span class="line">        <span class="type">int</span> so_error = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> optLen = <span class="built_in">sizeof</span>(so_error);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getsockopt</span>(sok, SOL_SOCKET, SO_ERROR, (<span class="type">char</span>*)&amp;so_error, &amp;optLen) == SOCKET_ERROR || so_error != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">closesocket</span>(sok);</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这说明 connect 已经完成了，可以恢复成阻塞模式</span></span><br><span class="line">    u_long Blocking = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ioctlsocket</span>(sok, FIONBIO, &amp;Blocking);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 04 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setSocketTimeout</span>(sok, <span class="number">500</span>);</span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 05 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数实现了客户端创建socket，且用非阻塞模式connect。然后恢复阻塞。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Av41187M8/">网络多线程细节处理：Socket阻塞与非阻塞</a></li>
</ol>


            <!-- Tags -->
            


<div class="tags">
    
</div>



            <!-- Comments -->
            <div>
                




            </div>
        </div><!-- end content -->
    </section>

    <!-- Table of Contents will be generated by toc-collapse.js -->

</section><!-- end main -->

<script>
	window.UI_LANG = {"en":{"menu":{"home":"Home","archives":"Archives","about":"About"},"footer":{"copyright":"Copyright © %year% %author%","powered":"Powered by %hexo%","modified":"Modified based on %theme%"},"buttons":{"language":"EN / 中"}},"zh":{"menu":{"home":"首页","archives":"归档","about":"关于"},"footer":{"copyright":"版权 © %year% %author%","powered":"由 %hexo% 驱动","modified":"基于 %theme% 主题定制"},"buttons":{"language":"中 / EN"}}};
	window.UI_DEFAULT_LANG = 'en';
</script>

<!-- After footer scripts -->

<!-- jQuery -->

<script src="/js/jquery.js"></script>


<!-- Custom Code -->

<script src="/js/main.js"></script>


<script src="/js/article-collapse.js"></script>


<script src="/js/toc-collapse.js"></script>


<script src="/js/shadertoy-embed.js"></script>


<script src="/js/image-zoom.js"></script>


<script src="/js/lang-toggle.js"></script>


<!-- Gallery -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Code Block Expansion Script -->
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function() {
    // Initialize code block expansion
    function initCodeBlockExpansion() {
        const codeBlocks = document.querySelectorAll('figure.highlight');
        
        codeBlocks.forEach(function(codeBlock) {
            // Skip if already processed
            if (codeBlock.closest('.code-block-container')) return;
            
            // Remove table structure and keep only code content
            const table = codeBlock.querySelector('table');
            if (table) {
                const codeCell = table.querySelector('td.code');
                if (codeCell) {
                    // Create a new pre element with code content
                    const newPre = document.createElement('pre');
                    newPre.className = 'code';
                    newPre.innerHTML = codeCell.innerHTML;
                    
                    // Replace table with pre element
                    codeBlock.innerHTML = '';
                    codeBlock.appendChild(newPre);
                }
            }
            
            // Get the code content height
            const codeContent = codeBlock.querySelector('pre.code');
            if (!codeContent) return;
            
            const actualHeight = codeContent.scrollHeight;
            const maxHeight = 400; // Same as CSS max-height
            
            // Create button container and copy button for all code blocks
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'code-buttons';
            
            // Create copy button (for all code blocks)
            const copyButton = document.createElement('button');
            copyButton.className = 'copy-code-button';
            copyButton.textContent = '复制代码';
            copyButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                copyCodeToClipboard(codeContent, copyButton);
            });
            buttonsContainer.appendChild(copyButton);

            // Only add expansion if content is taller than max height
            if (actualHeight > maxHeight) {
                // Wrap the code block in a container
                const container = document.createElement('div');
                container.className = 'code-block-container collapsed';
                codeBlock.parentNode.insertBefore(container, codeBlock);
                container.appendChild(codeBlock);

                // Create expand button
                const expandButton = document.createElement('button');
                expandButton.className = 'expand-button';
                expandButton.textContent = '展开代码';
                buttonsContainer.appendChild(expandButton);

                // Add buttons container to the wrapper
                container.appendChild(buttonsContainer);

                // Add click handler
                expandButton.addEventListener('click', function() {
                    if (container.classList.contains('collapsed')) {
                        // Expand to full screen
                        showFullscreenCode(codeBlock, expandButton);
                    }
                });
            } else {
                // For code blocks that don't need expansion, just add copy button
                const container = document.createElement('div');
                container.className = 'code-block-container';
                codeBlock.parentNode.insertBefore(container, codeBlock);
                container.appendChild(codeBlock);
                container.appendChild(buttonsContainer);
            }
        });
    }
    
    function showFullscreenCode(codeBlock, button) {
        // Create fullscreen modal
        const modal = document.createElement('div');
        modal.className = 'code-fullscreen-modal active';
        
        const content = document.createElement('div');
        content.className = 'code-fullscreen-content';
        
        // Clone the closest code container (includes wrapper if present)
        const sourceContainer = codeBlock.closest('.code-block-container');
        const clonedBlock = (sourceContainer || codeBlock).cloneNode(true);

        // Remove any buttons that don't make sense inside the modal
        const extraneousControls = clonedBlock.querySelectorAll('.code-buttons, .copy-code-button, .expand-button');
        extraneousControls.forEach(function(el) {
            el.parentNode && el.parentNode.removeChild(el);
        });
        
        // Ensure wrapper/container fills the modal and isn't marked as collapsed
        const wrapper = clonedBlock.classList.contains('code-block-container')
            ? clonedBlock
            : clonedBlock.querySelector('.code-block-container');
        if (wrapper) {
            wrapper.classList.remove('collapsed');
            wrapper.style.margin = '0';
        }
        
        // Find and update the pre.code element in cloned block
        const clonedPre = (wrapper || clonedBlock).querySelector('pre.code');
        if (clonedPre) {
            clonedPre.scrollTop = 0;
        }

        content.appendChild(clonedBlock);
        
        // Create close button
        const closeButton = document.createElement('button');
        closeButton.className = 'close-fullscreen';
        closeButton.textContent = '关闭';
        content.appendChild(closeButton);
        
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        // Prevent body scrolling
        document.body.style.overflow = 'hidden';
        
        // Close handlers
        function closeModal() {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
        }
        
        closeButton.addEventListener('click', closeModal);
        
        // Close on backdrop click
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeModal();
            }
        });
        
        // Close on escape key
        function handleKeydown(e) {
            if (e.key === 'Escape') {
                closeModal();
                document.removeEventListener('keydown', handleKeydown);
            }
        }
        document.addEventListener('keydown', handleKeydown);
    }
    
    // Function to copy code to clipboard
    function copyCodeToClipboard(codeElement, button) {
        let code = codeElement.textContent || codeElement.innerText;
        
        // Use modern Clipboard API if available
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(code).then(function() {
                showCopySuccess(button);
            }).catch(function(err) {
                console.error('复制失败:', err);
                fallbackCopy(code, button);
            });
        } else {
            fallbackCopy(code, button);
        }
    }

    // Fallback copy method for older browsers
    function fallbackCopy(text, button) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.top = '0';
        textArea.style.left = '0';
        textArea.style.width = '2em';
        textArea.style.height = '2em';
        textArea.style.padding = '0';
        textArea.style.border = 'none';
        textArea.style.outline = 'none';
        textArea.style.boxShadow = 'none';
        textArea.style.background = 'transparent';
        
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                showCopySuccess(button);
            }
        } catch (err) {
            console.error('复制失败:', err);
        }
        
        document.body.removeChild(textArea);
    }

    // Show copy success feedback
    function showCopySuccess(button) {
        const originalText = button.textContent;
        button.classList.add('copied');
        button.textContent = '已复制 ✓';
        
        setTimeout(function() {
            button.classList.remove('copied');
            button.textContent = originalText;
        }, 2000);
    }

    // Initialize on page load
    initCodeBlockExpansion();
    
    // Re-initialize if new content is loaded (for SPA-like behavior)
    const observer = new MutationObserver(function(mutations) {
        let needsReinit = false;
        mutations.forEach(function(mutation) {
            if (mutation.addedNodes.length > 0) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.nodeType === 1 && (node.matches('figure.highlight') || node.querySelector('figure.highlight'))) {
                        needsReinit = true;
                    }
                });
            }
        });
        if (needsReinit) {
            setTimeout(initCodeBlockExpansion, 100);
        }
    });
    
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
});
</script>

<!-- Mermaid Initialization -->
<script type="text/javascript">
    // Wait for document ready
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof mermaid !== 'undefined') {
            // Initialize with proper configuration
            mermaid.initialize({ 
                startOnLoad: false,
                theme: 'default',
                securityLevel: 'loose'
            });
            
            // Find and process mermaid code blocks
            const codeBlocks = document.querySelectorAll('figure.highlight.plaintext .code');
            
            codeBlocks.forEach((codeElement, index) => {
                let code = codeElement.textContent || codeElement.innerText;
                
                // Check if it's a mermaid diagram
                if (code.trim().match(/^(graph|flowchart|sequenceDiagram|classDiagram|stateDiagram|journey|pie|gitgraph|erDiagram)/)) {
                    // Critical fix: Remove ALL leading/trailing whitespace and newlines
                    code = code.trim().replace(/^\s+|\s+$/g, '');
                    
                    // Create mermaid div
                    const mermaidDiv = document.createElement('div');
                    mermaidDiv.className = 'mermaid';
                    // Set the cleaned code without any extra whitespace
                    mermaidDiv.textContent = code;
                    mermaidDiv.id = 'mermaid-diagram-' + index;
                    
                    // Replace the entire figure element
                    const figureElement = codeElement.closest('figure');
                    if (figureElement) {
                        figureElement.parentNode.replaceChild(mermaidDiv, figureElement);
                    }
                }
            });
            
            // Initialize mermaid diagrams with explicit selector
            setTimeout(() => {
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }, 100);
        }
    });
</script>

<!-- ShaderToy Placeholder Processing -->
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for other scripts to load
    setTimeout(function() {
        // Find all elements with shadertoy-placeholder class
        const elements = document.querySelectorAll('.shadertoy-placeholder[data-id]');
        
        console.log('Found shadertoy-placeholder elements:', elements.length);

        elements.forEach(element => {
            const shaderID = element.getAttribute('data-id');
            console.log('Processing shadertoy-placeholder element with ID:', shaderID);
            
            if (shaderID) {
                // Create iframe container
                const container = document.createElement('div');
                container.style.cssText = `
                    position: relative;
                    width: 100%;
                    height: 400px;
                    margin: 20px 0;
                    border: 2px solid #bfbbbb;
                    border-radius: 8px;
                    overflow: hidden;
                    background-color: #f6f6f6;
                `;

                // Create iframe
                const iframe = document.createElement('iframe');
                iframe.src = `https://www.shadertoy.com/embed/${shaderID}?gui=true&t=10&paused=false&muted=false`;
                iframe.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    border: none;
                `;
                iframe.allowFullscreen = true;
                iframe.loading = 'lazy';

                container.appendChild(iframe);
                element.parentNode.insertBefore(container, element);
                element.parentNode.removeChild(element);
            }
        });
    }, 1000); // Wait a full second for everything to load
});
</script>

<!-- Disqus Comments -->


</body>

</html>