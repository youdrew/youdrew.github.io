<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="无标记动作捕捉使用及插件接入相关资料网站CapturyLiveLink_5.2API文档官方教程
Captury测试和使用方法打开 CapturyReplay
导入 lanqiu 动捕数据数据的存储路径不能出现中文路径否则会导入失败

打开 ShotInfo 和 retarget 视图


加载目标">
    

    <!--Author-->
    
        <meta name="author" content="Eugene Hsuan">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Captury无标记动作捕捉使用及插件接入问题"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Eugene&#39;s Page"/>

    <!--Article Language-->
    
        <meta name="article:lang" content="en"/>
    

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>Captury无标记动作捕捉使用及插件接入问题 - Eugene&#39;s Page</title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/css/table.css">

    
<link rel="stylesheet" href="/css/image-zoom.css">

    
<link rel="stylesheet" href="/css/language-switcher.css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Mermaid Support -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>

    <!-- Google Analytics -->
    


    <!--Favicon-->
    
        <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/img/favicon.ico" type="image/x-icon">
    

    
        <link rel="alternate" type="application/atom+xml" title="Eugene&#39;s Page" href="/atom.xml">
    
        <link rel="alternate" type="application/rss+xml" title="Eugene&#39;s Page" href="/rss.xml">
    

<meta name="generator" content="Hexo 8.1.1"></head>


<body class="layout-post path-2025-12-01-Capturymarkerless-">

<!-- Menu -->
<!-- Navigation -->
<header>
    <div class="logo">
        <a href="/">Eugene's Page</a>
        <div class="subtitle"></div>
        <div class="description"></div>
    </div><!-- end logo -->

    <div id="menu_icon"></div>
    <nav>
        <ul>
            
            <li>
                <a href="/" data-i18n-key="Home">Home</a>
            </li>
            
            <li>
                <a href="/archives" data-i18n-key="Archives">Archives</a>
            </li>
            
            <li>
                <a href="/about" data-i18n-key="About">About</a>
            </li>
            
        </ul>
    </nav><!-- end navigation menu -->

    <div class="footer clearfix">
        <ul class="social clearfix">
            
                <li><a href="https://space.bilibili.com/29291963" class="behance" target="_blank" data-title="Bilibili"></a></li>
            
            
                <li><a href="https://www.instagram.com/yu_chinghsuan?igsh=Mm54ajloc3c1NW5m&utm_source=qr" class="instagram" target="_blank" data-title="Instagram"></a></li>
            
            
                <li><a href="https://www.douban.com/people/Youdrew_Xuan/" class="dribble" target="_blank" data-title="Douban"></a></li>
            
            
                <li><a href="mailto:youdrewxuan@icloud.com" class="google" target="_blank" data-title="Email"></a></li>
            
            
                <li><a href="/rss.xml" class="rss" target="_blank" data-title="RSS"></a></li>
            
            <li><a href="javascript:void(0);" class="language" id="langSwitch" data-title="Language"></a></li>
        </ul><!-- end social -->

        <div class="rights">
            <p><span data-i18n="Copyright">Copyright</span> © 2026 Eugene Hsuan</p>
            <p><span data-i18n="Powered by">Powered by</span> <a href="https://hexo.io/" target="_blank">Hexo</a></p>
            <p><span data-i18n="Modified based on">Modified based on</span> <a href="https://github.com/klugjo/hexo-theme-magnetic" target="_blank">Magnetic</a> <span data-i18n="theme">theme</span></p>
            <p data-i18n="Mainly maintained using AI">Mainly maintained using AI</p>
        </div><!-- end rights -->
    </div ><!-- end footer -->
</header><!-- end header -->


<!-- Main Content -->
<section class="main clearfix">

    <section class="top" style="background: url('https://s2.loli.net/2025/09/13/vlTKo196wnDypC2.png');">
        <div class="wrapper content_header clearfix">
            

<div class="work_nav">

    <ul class="btn clearfix">
        
        <li><a href="/2026/02/19/VibeCoding/" class="previous" data-title="Vibe Coding（结对编程）系统性学习"></a></li>
        
        <li><a href="/" class="grid" data-title="Portfolio"></a></li>
        
        <li><a href="/2025/11/21/Unreal%20RemoteControl%20Note/" class="next" data-title="虚幻5远程控制（RemoteCon..."></a></li>
        
    </ul>

</div><!-- end work_nav -->
            <h1 class="title">Captury无标记动作捕捉使用及插件接入问题</h1>
        </div>
    </section><!-- end top -->

    <section class="wrapper">
        <div class="content">

            <!-- Gallery -->
            

            <!-- Content -->
            <h1 id="无标记动作捕捉使用及插件接入"><a href="#无标记动作捕捉使用及插件接入" class="headerlink" title="无标记动作捕捉使用及插件接入"></a>无标记动作捕捉使用及插件接入</h1><h2 id="相关资料网站"><a href="#相关资料网站" class="headerlink" title="相关资料网站"></a>相关资料网站</h2><p><a target="_blank" rel="noopener" href="https://www.fab.com/listings/69ee923d-1a3a-42be-8f2a-9924b6e7b79a">CapturyLiveLink</a>_5.2<br><a target="_blank" rel="noopener" href="http://doc.captury.com/python.html">API文档</a><br><a target="_blank" rel="noopener" href="http://doc.captury.com/CapturyLive/index.html#overview">官方教程</a></p>
<h2 id="Captury测试和使用方法"><a href="#Captury测试和使用方法" class="headerlink" title="Captury测试和使用方法"></a>Captury测试和使用方法</h2><h3 id="打开-CapturyReplay"><a href="#打开-CapturyReplay" class="headerlink" title="打开 CapturyReplay"></a>打开 CapturyReplay</h3><p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251212111952293.png" alt="image-20251212111952293"></p>
<h3 id="导入-lanqiu-动捕数据"><a href="#导入-lanqiu-动捕数据" class="headerlink" title="导入 lanqiu 动捕数据"></a>导入 lanqiu 动捕数据</h3><p>数据的存储路径不能出现中文路径否则会导入失败</p>
<p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251212111946140.png" alt="image-20251212111946140"></p>
<p>打开 ShotInfo 和 retarget 视图</p>
<p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251212111936943.png" alt="image-20251212111936943"></p>
<p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251212111930610.png" alt="image-20251212111930610"></p>
<h3 id="加载目标"><a href="#加载目标" class="headerlink" title="加载目标"></a>加载目标</h3><p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251212111921791.png" alt="image-20251212111921791"></p>
<h3 id="选择骨骼"><a href="#选择骨骼" class="headerlink" title="选择骨骼"></a>选择骨骼</h3><p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251212111913119.png" alt="image-20251212111913119"></p>
<h3 id="设置数据源"><a href="#设置数据源" class="headerlink" title="设置数据源"></a>设置数据源</h3><p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251212111904207.png" alt="image-20251212111904207"></p>
<p>unknown和unknown-2分别对应两个角色</p>
<p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251212111717722.png" alt="image-20251212111717722"></p>
<h2 id="Captury原始插件底层sock阻塞问题"><a href="#Captury原始插件底层sock阻塞问题" class="headerlink" title="Captury原始插件底层sock阻塞问题"></a>Captury原始插件底层sock阻塞问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在插件接入的时候（插件已经完成了接入，数据已经连通），但遇到一个问题：</p>
<p>用户反馈，如果要从Captury信号源切换到别的信号源的时候，会发生卡顿的现象。</p>
<p>卡顿时间在固定的20s左右。</p>
<p><img src="https://s2.loli.net/2025/12/12/BadAWXIFlsDhqo4.png" alt="image-20251205150209762"><img src="https://s2.loli.net/2025/12/12/iJ5ZWet3KbP4r2v.png" alt="image-20251205150637519"></p>
<p>且这个问题仅仅发生在<u>Captury信号源没连接上的状态</u>中。如果信号连接上了，切换这个操作不会发生卡顿。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>这个操作背后的逻辑是，用户切到别的信号源，我会销毁掉已经生成的CapturyLivelink，确保Livelink信号池子干净。</p>
<p>同时，刷新信号的按钮也会出现这个问题，因为刷新的时候，我背后做的操作是：先删除掉老的CapturyLivelink，然后在创建新的连接数据。</p>
<p>且为了防止出现底层数据竞争的问题。我永远只允许一个CapturyLivelink信号源出现。</p>
<p>所以，在切到别的信号源的时候，我永远会销毁掉老的信号源。而问题就发生在删除老的信号源上面，只要一旦要销毁没有连上的老的信号源，就会发生这个20s左右的卡顿。</p>
<p>可是为什么是“没有连接上”才会发生卡顿，而正常情况下不会呢？<u>暂时不得而知。所以暂时推断问题应该在底层断连逻辑这一块。</u></p>
<p>通过Unreal Insight发现，在执行了Captury_disconnect操作之后。整个系统陷入等待，时间会有三十多秒。</p>
<p><img src="C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20251205153031066.png" alt="image-20251205153031066"></p>
<p>所以这里确定了是断连操作造成了这个卡顿。</p>
<p>然后 我在卡顿的（这十几秒里）时候，暂停了IDE，看看当前Game停在了哪里，Game停在了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(receiveThread, INFINITE);</span><br></pre></td></tr></table></figure>

<p>这一句话。这句话是我前几天加的，考虑到两个CapturyLivelink会出现多线程的问题，底层占用会导致崩溃，所以我写了需要等待底下工作的线程真正地退出，才算完成退出操作。</p>
<p>所以我意识到了，问题应该是出在了receiveThread线程的loop里。</p>
<p>于是开始在整个链路上打Log寻找罪魁祸首看看是哪个接口造成的。<br>并且在链路中添加更多地退出机制（stopReceiving、bExternalShutdownRequested），看看能否去掉卡顿。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="function">DWORD <span class="title">RemoteCaptury::receiveLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">RemoteCaptury::receiveLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> handshaking = !handshakeFinished;</span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;01 starting receive loop %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="comment">//log(&quot;starting receive loop\n&quot;);</span></span><br><span class="line">    <span class="keyword">while</span> (!stopReceiving</span><br><span class="line">       &amp;&amp; !bExternalShutdownRequested </span><br><span class="line">       &amp;&amp; (!handshaking || !handshakeFinished)) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;02 receive loop iteration %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">receive</span>(sock)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sock == <span class="number">-1</span></span><br><span class="line">             &amp;&amp; !stopReceiving</span><br><span class="line">             &amp;&amp; !bExternalShutdownRequested )</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="built_in">deleteActors</span>();</span><br><span class="line">                cameras.<span class="built_in">clear</span>();</span><br><span class="line">                numCameras = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;03 socket closed, reconnecting %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">                <span class="keyword">if</span> (isStreamThreadRunning) &#123;</span><br><span class="line">                   stopStreamThread = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">                   <span class="built_in">WaitForSingleObject</span>(streamThread, <span class="number">1000</span>);</span><br><span class="line">                   <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                   <span class="type">void</span>* retVal;</span><br><span class="line">                   <span class="built_in">pthread_join</span>(streamThread, &amp;retVal);</span><br><span class="line">                   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;03 a socket closed, reconnecting %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;04-1 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">             <span class="keyword">while</span> (!stopReceiving) &#123;</span><br><span class="line">                <span class="comment">// 停止重连</span></span><br><span class="line">                sock = <span class="built_in">openTcpSocket</span>();</span><br><span class="line">                <span class="comment">//UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;04-2 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">                <span class="keyword">if</span> (sock != <span class="number">-1</span>)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">sleepMicroSeconds</span>(<span class="number">1000</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;04-3 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (streamWhat != CAPTURY_STREAM_NOTHING)</span><br><span class="line">                <span class="built_in">Captury_startStreamingImagesAndAngles</span>(<span class="keyword">this</span>, streamWhat, streamCamera, (<span class="type">int</span>)streamAngles.<span class="built_in">size</span>(), streamAngles.<span class="built_in">data</span>());</span><br><span class="line">                <span class="comment">//UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;05 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">             </span><br><span class="line">             handshaking = <span class="literal">false</span>; <span class="comment">// this is a lie but makes it go into the normal loop</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//log(&quot;stopping receive loop\n&quot;);</span></span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;06 %d %s&quot;), testcount++, *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果Log查出问题了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Display LogCaptury CapturyLiveLink: request shutdown</span><br><span class="line">Warning LogCapturyRemote Captury_stopStreaming() called</span><br><span class="line">Warning LogCapturyRemote Captury_disconnect() called</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() called</span><br><span class="line"></span><br><span class="line">Warning LogCapturyRemote 01 starting receive loop 267 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote 02 receive loop iteration 268 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote 03 socket closed, reconnecting 269 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote 03 a socket closed, reconnecting 270 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote Captury_disconnect() called</span><br><span class="line">Warning LogCapturyRemote 04-1 271 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() called</span><br><span class="line">Warning LogCapturyRemote openTcpSocket() 01 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote openTcpSocket() 02 2025.12.04-18.57.03</span><br><span class="line">Warning LogCapturyRemote openTcpSocket() 03 2025.12.04-18.57.03</span><br><span class="line">Display LogCaptury CapturyLiveLink: request shutdown</span><br><span class="line">Warning LogCapturyRemote Captury_stopStreaming() called</span><br><span class="line">Warning LogCapturyRemote Captury_disconnect() called</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() called</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() **: waiting for receiveThread 2025.12.04-18.57.05</span><br><span class="line">Warning LogCapturyRemote 04-2 272 2025.12.04-18.57.24</span><br><span class="line">Warning LogCapturyRemote 04-3 273 2025.12.04-18.57.24</span><br><span class="line">Warning LogCapturyRemote 06 274 2025.12.04-18.57.24</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() **: receiveThread finished 2025.12.04-18.57.24</span><br><span class="line"></span><br><span class="line">Display LogCaptury CapturyLiveLink: request shutdown</span><br><span class="line">Warning LogCapturyRemote Captury_stopStreaming() called</span><br><span class="line">Warning LogCapturyRemote Captury_disconnect() called</span><br><span class="line">Warning LogCapturyRemote RemoteCaptury::disconnect() called</span><br></pre></td></tr></table></figure>

<p>其中openTcpSocket()+数字的部分以及RemoteCaptury::disconnect() 是我游戏线程。</p>
<p>当我下达关机指令的时候，remote线程卡在了04-1和04-2之间。并且remote线程是活的。所以大家都在等remote线程。</p>
<p>而这两个Log之间夹的函数就是sock &#x3D; openTcpSocket();</p>
<p>这个函数的作用是：创建一个 TCP，套接字并尝试与远程地址建立连接。</p>
<p>下面是原始的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">RemoteCaptury::openTcpSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;opening TCP socket\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SOCKET sok = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sok == <span class="number">-1</span>)</span><br><span class="line">       <span class="keyword">return</span> (SOCKET)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localAddress.sin_port != <span class="number">0</span> &amp;&amp; <span class="built_in">bind</span>(sok, (sockaddr*) &amp;localAddress, <span class="built_in">sizeof</span>(localAddress)) != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">closesocket</span>(sok);</span><br><span class="line">       <span class="keyword">return</span> (SOCKET)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">connect</span>(sok, (sockaddr*) &amp;remoteAddress, <span class="built_in">sizeof</span>(remoteAddress)) != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">closesocket</span>(sok);</span><br><span class="line">       <span class="keyword">return</span> (SOCKET)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set read timeout</span></span><br><span class="line">    <span class="built_in">setSocketTimeout</span>(sok, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIN32</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;connected to %s:%d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;remoteAddress.sin_addr, buf, <span class="number">100</span>), <span class="built_in">ntohs</span>(remoteAddress.sin_port));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过加Log发现，函数卡在了。</p>
<p><code>if (::connect(sok, (sockaddr*) &amp;remoteAddress, sizeof(remoteAddress)) != 0) </code></p>
<p>这个if判断里面，而这个接口是windows的sock接口。ok，至此，已经找到罪魁祸首了。</p>
<h3 id="底层逻辑阐述"><a href="#底层逻辑阐述" class="headerlink" title="底层逻辑阐述"></a>底层逻辑阐述</h3><p><img src="https://s2.loli.net/2025/12/12/TKXsv3z1uHMeBgn.png" alt="image-20251205123239125"></p>
<p>这一节想解释清楚两件事：</p>
<ol>
<li><strong>为什么阻塞式 <code>connect</code> 会在「没连上」的时候卡住几十秒</strong>；</li>
<li>这个行为和阻塞 &#x2F; 非阻塞、缓冲区、IO 多路复用之间的关系。</li>
</ol>
<h4 id="1-阻塞-connect-为什么会卡很久"><a href="#1-阻塞-connect-为什么会卡很久" class="headerlink" title="1. 阻塞 connect 为什么会卡很久"></a>1. 阻塞 <code>connect</code> 为什么会卡很久</h4><p>原始代码里的 <code>openTcpSocket</code> 使用的是<strong>阻塞 socket + 阻塞 <code>connect</code></strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sok = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (::<span class="built_in">connect</span>(sok, (sockaddr*)&amp;remoteAddress, <span class="built_in">sizeof</span>(remoteAddress)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(sok);</span><br><span class="line">        <span class="keyword">return</span> (SOCKET)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在阻塞模式下：</p>
<ul>
<li><code>connect</code> 会进入内核，等待 TCP 三次握手完成或者失败；</li>
<li>如果远端服务没开 &#x2F; IP 不可达 &#x2F; 包被丢弃，系统会按自己的重试策略不断发 SYN、等待回应；</li>
<li>在这段时间里，调用 <code>connect</code> 的线程会一直被挂起，直到<strong>内核判定“连接失败”并超时返回</strong>；</li>
<li>这个超时通常是几十秒级（你实际观测到的就是 ~20s）。</li>
</ul>
<p>结合上面的 receiveLoop，可以看到：</p>
<ul>
<li><code>receiveLoop</code> 在重连时会反复调用 <code>sock = openTcpSocket();</code>；</li>
<li>当 Captury 端没开的时候，每次 <code>openTcpSocket()</code> 都会在 <code>connect</code> 内部卡到系统超时；</li>
<li>你的 <code>disconnect()</code> 又在 <code>WaitForSingleObject(receiveThread, INFINITE);</code> 等这个线程自然退出；</li>
<li>于是 Game 线程就被这一条阻塞式 <code>connect</code> 间接拖住了几十秒。</li>
</ul>
<p>也就是说，这里并不是逻辑死锁，而是<strong>单纯被内核的阻塞连接等待住了</strong>。</p>
<h4 id="2-阻塞-I-O、缓冲区和-IO-多路复用问题（扩展）"><a href="#2-阻塞-I-O、缓冲区和-IO-多路复用问题（扩展）" class="headerlink" title="2. 阻塞 I&#x2F;O、缓冲区和 IO 多路复用问题（扩展）"></a>2. 阻塞 I&#x2F;O、缓冲区和 IO 多路复用问题（扩展）</h4><p>阻塞的问题不只出现在 <code>connect</code>，也同样存在于 <code>read</code> &#x2F; <code>write</code>（WinSock 里的 <code>recv</code> &#x2F; <code>send</code>）：</p>
<ul>
<li>阻塞模式下：<ul>
<li><code>recv</code> 在缓冲区“没数据可读”时会一直等；</li>
<li><code>send</code> 在发送缓冲区满时会一直等；</li>
<li>线程就挂在这些系统调用里，直到有数据或有空位。</li>
</ul>
</li>
</ul>
<p>这几张图，其实就是描述：应用线程在访问一个<strong>内核缓冲区</strong>——</p>
<img src="https://s2.loli.net/2025/12/12/nQBb1Okzg4DRplY.png" alt="image-20251205142827661" style="zoom:25%;" />

<ul>
<li>读的时候：如果缓冲区里<strong>暂时没数据</strong>，阻塞 <code>read/recv</code> 会卡住线程；</li>
<li>写的时候：如果缓冲区已经<strong>写满</strong>，阻塞 <code>write/send</code> 会卡在那儿等内核把旧数据发走。</li>
</ul>
<img src="https://s2.loli.net/2025/12/12/LDI2tulmi7FC3e8.png" alt="image-20251205144248299" style="zoom:25%;" />

<img src="https://s2.loli.net/2025/12/12/LkBPTgxOGZEC6Nc.png" alt="image-20251205144319439" style="zoom:25%;" />

<p>在“阻塞模型”下（原来的代码），如果网络线程直接在这些调用上阻塞：</p>
<ul>
<li><p>它就<strong>没法及时响应退出信号</strong>（<code>stopReceiving</code> &#x2F; <code>bExternalShutdownRequested</code> 等）；</p>
</li>
<li><p>像 <code>disconnect()</code> 这种需要“等待线程正常退出”的逻辑，也都会被一起拖住。比如下下面这张图片，多线程的阻塞模式，会在有大量连接调用的时候，开辟多个线程，去做连接，一个服务一个连接，这个服务断掉了这个，这个线程占用才结束，这是一个很古早的调用方式，因为线程其实也是很珍贵的资源，一台电脑总共也没几个线程。（回到我的项目里，因为我只允许运行一个Captury线程，而且Game线程会等这个线程，所以整个游戏卡着。当然我这么做也有别的考量）</p>
<img src="https://s2.loli.net/2025/12/12/aqvzLWVgDebHmps.png" alt="image-20251205191914919" style="zoom:25%;" /></li>
</ul>
<p> <strong>IO 多路复用（<code>select</code> &#x2F; <code>poll</code> &#x2F; <code>epoll</code> &#x2F; <code>WSAPoll</code>）</strong>，本质上是在做一件事：</p>
<ul>
<li>不把线程挂死在 <code>read/write/connect</code> 上，而是：<ul>
<li>先在一个“描述符集合”上等「可读 &#x2F; 可写 &#x2F; 异常」事件；</li>
<li>只有当内核告诉你“这个 fd 已经准备好”时，再真正去 <code>read/recv</code> 或 <code>write/send</code>；</li>
<li>这个等待可以设置自定义超时（例如 10ms、100ms、1s），并在每次醒来时检查退出条件。</li>
</ul>
</li>
</ul>
<h4 id="3-非阻塞-ioctlsocket-在这里的作用"><a href="#3-非阻塞-ioctlsocket-在这里的作用" class="headerlink" title="3. 非阻塞 + ioctlsocket 在这里的作用"></a>3. 非阻塞 + <code>ioctlsocket</code> 在这里的作用</h4><p><code>ioctlsocket(sok, FIONBIO, &amp;NonBlocking)</code> 就是把 socket 从“阻塞模式”切换到“非阻塞模式”。</p>
<p>在非阻塞模式下：</p>
<ul>
<li><code>connect</code> 不再把线程挂死，而是：<ul>
<li>立刻返回一个错误码（例如 <code>WSAEWOULDBLOCK / WSAEINPROGRESS</code>），表示“连接还在进行中”；</li>
<li>后续由你自己用 <code>select</code> &#x2F; <code>WSAPoll</code> 等来轮询「这条连接是否已经成功&#x2F;失败」，并且可以<strong>自己控制最大等待时间</strong>；</li>
</ul>
</li>
<li><code>read/recv</code>、<code>write/send</code> 遇到没数据 &#x2F; 缓冲区满时，也会立刻返回 <code>EWOULDBLOCK</code>，由你的逻辑决定下一步怎么做，而不是直接卡死线程。</li>
</ul>
<p>总结一下这一节：</p>
<ul>
<li><strong>根因</strong>：阻塞 <code>connect</code> 在目标不可达时会触发系统级长超时，线程被内核挂起几十秒；</li>
<li><strong>放大器</strong>：你的 <code>receiveLoop</code> 在重连路径里频繁调用 <code>openTcpSocket()</code>，而 <code>disconnect()</code> 又必须等线程退出；</li>
<li><strong>改成非阻塞的目的</strong>：用 <code>ioctlsocket(FIONBIO)</code> + <code>select</code> 自己控制等待时长和退出时机，把“不可控的 20s 超时”变成“可控的 1s 以内失败”，从而让 <code>disconnect()</code> 快速返回。</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://s2.loli.net/2025/12/12/TKXsv3z1uHMeBgn.png" alt="image-20251205123239125"></p>
<p>非阻塞是“通过修改套接字模式”实现的——代码在 socket() 之后、connect() 之前把套接字设为非阻塞，因此 connect() 就是在非阻塞模式下执行的；连接完成后再把套接字恢复成阻塞。</p>
<ul>
<li>所以其实我这个修改后的代码，并不是完全非阻塞的。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>因为这里调用了底层 WinSock 的 connect。<br>它是 Windows 提供的系统调用，没办法在内部加条件判断。</p>
<p>我们只能：</p>
<ul>
<li>要么换一种调用方式（非阻塞 + 自己用 select&#x2F;WSAPoll 控制超时）；</li>
<li>要么在调用 connect 前后做逻辑，比如提前检测 stopReceiving，或者调用后在另一个线程里强制 closesocket。</li>
</ul>
<p>但这个方案不是很问题，需要维护另外一个线程来关闭这个线程。听起来就很麻烦。所以我用前者，来改造一个非阻塞的sock。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">RemoteCaptury::openTcpSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 01 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="comment">// 函数通过调用 socket 创建一个套接字。如果创建失败（返回 INVALID_SOCKET），函数直接返回错误状态</span></span><br><span class="line">    SOCKET sok = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sok == INVALID_SOCKET)</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 02 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="comment">// 如果 localAddress 的端口号不为 0，函数会尝试将套接字绑定到指定的本地地址。如果绑定失败，同样关闭套接字并返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (localAddress.sin_port != <span class="number">0</span> &amp;&amp; <span class="built_in">bind</span>(sok, (sockaddr*)&amp;localAddress, <span class="built_in">sizeof</span>(localAddress)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(sok);</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 03 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line">    <span class="comment">// 1. 先设成非阻塞</span></span><br><span class="line">    u_long NonBlocking = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctlsocket</span>(sok, FIONBIO, &amp;NonBlocking) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(sok);</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尝试发起 connect</span></span><br><span class="line">    <span class="type">int</span> ConnectResult = ::<span class="built_in">connect</span>(sok, (sockaddr*)&amp;remoteAddress, <span class="built_in">sizeof</span>(remoteAddress));</span><br><span class="line">    <span class="keyword">if</span> (ConnectResult == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="type">int</span> Err = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">if</span> (Err != WSAEWOULDBLOCK &amp;&amp; Err != WSAEINPROGRESS &amp;&amp; Err != WSAEALREADY) &#123;</span><br><span class="line">            <span class="comment">// 真错误，直接失败</span></span><br><span class="line">            <span class="built_in">closesocket</span>(sok);</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 连接正在进行中，用 select 等待一小段时间</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MaxWaitMillis = <span class="number">1000</span>; <span class="comment">// 1 秒上限</span></span><br><span class="line">        fd_set WriteSet;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;WriteSet);</span><br><span class="line">        <span class="built_in">FD_SET</span>(sok, &amp;WriteSet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> Tv;</span><br><span class="line">        Tv.tv_sec = MaxWaitMillis / <span class="number">1000</span>;</span><br><span class="line">        Tv.tv_usec = (MaxWaitMillis % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> Sel = <span class="built_in">select</span>((<span class="type">int</span>)(sok + <span class="number">1</span>), <span class="literal">nullptr</span>, &amp;WriteSet, <span class="literal">nullptr</span>, &amp;Tv);</span><br><span class="line">        <span class="keyword">if</span> (Sel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 超时或 select 出错，都当失败</span></span><br><span class="line">            <span class="built_in">closesocket</span>(sok);</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. select 说 socket 可写了，用 SO_ERROR 再确认一次</span></span><br><span class="line">        <span class="type">int</span> so_error = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> optLen = <span class="built_in">sizeof</span>(so_error);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getsockopt</span>(sok, SOL_SOCKET, SO_ERROR, (<span class="type">char</span>*)&amp;so_error, &amp;optLen) == SOCKET_ERROR || so_error != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">closesocket</span>(sok);</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这说明 connect 已经完成了，可以恢复成阻塞模式</span></span><br><span class="line">    u_long Blocking = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ioctlsocket</span>(sok, FIONBIO, &amp;Blocking);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 04 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setSocketTimeout</span>(sok, <span class="number">500</span>);</span><br><span class="line">    <span class="comment">// UE_LOG(LogCapturyRemote , Warning, TEXT(&quot;openTcpSocket() 05 %s&quot;), *(FDateTime::Now().ToString()));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数实现了客户端创建socket，且用非阻塞模式connect。然后恢复阻塞。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Av41187M8/">网络多线程细节处理：Socket阻塞与非阻塞</a></li>
</ol>
<h2 id="Livelink的数据的实现方式的不同"><a href="#Livelink的数据的实现方式的不同" class="headerlink" title="Livelink的数据的实现方式的不同"></a>Livelink的数据的实现方式的不同</h2><p>可以理解成两种：可被 Finder 发现的 Message Bus Provider，以及直连 IP&#x2F;端口的自定义&#x2F;专用 Source。</p>
<p>它们最终都会把数据喂给 LiveLink Client，但“发现、连接、网络形态、运维方式”差异很大。</p>
<table>
<thead>
<tr>
<th></th>
<th>Finder+Message Bus</th>
<th>直连 IP</th>
</tr>
</thead>
<tbody><tr>
<td>发现与连接方式</td>
<td>通过 UE 的 UDP Messaging&#x2F;Message Bus 做 广播&#x2F;多播 Ping&#x2F;Pong。<br/>ULiveLinkMessageBusFinder::GetAvailableProviders() 只能列出“会回 FLiveLinkPongMessage 的 Provider”。<br/>优点：自动发现，不用手填 IP。</td>
<td>Source 自己实现网络协议（TCP&#x2F;UDP&#x2F;自定义端口），通常在 UI&#x2F;蓝图里 手动输入 IP（和可能的端口） 来连。<br/>你项目里的 Captury 就属于这一类：ConnectCapturyLiveLinkSource(const FString&amp; IpAddress, bool bUseTCP, …) 明确以 IP 为入口，并且还能选 TCP&#x2F;压缩&#x2F;Tag 等传输选项。<br/>优点：不依赖 Message Bus 生态，协议可控。</td>
</tr>
<tr>
<td>网络依赖与可达性</td>
<td>依赖：UDP Messaging、正确网卡绑定、允许多播&#x2F;广播、Windows 防火墙放行。<br/>常见问题：多网卡绑错、跨网段&#x2F;VLAN&#x2F;AP 隔离导致发现不到。</td>
<td>依赖：目标 IP&#x2F;端口可达即可（更像传统 C&#x2F;S）。<br/>更容易跨子网&#x2F;路由（只要网络策略允许），但要处理端口开放与 NAT&#x2F;防火墙规则。</td>
</tr>
<tr>
<td>数据“来源形态”与协议语义</td>
<td>“数据来源”通常是一个 Provider 服务，对外暴露“可发现的 Provider+若干 Subjects”。<br/>通信语义包含“发现&#x2F;握手&#x2F;版本”等（例如 Pong 里带版本、机器名等）。</td>
<td>“数据来源”就是某个设备&#x2F;应用在某端口输出的数据流，只要连上就收数据。<br/>语义完全由插件定义（例如 Captury 的 bStreamCompressed、bStreamARTags 这类能力开关）。</td>
</tr>
<tr>
<td>生命周期与稳定性</td>
<td>Provider 上下线会通过发现机制变化；但“只发现不等于稳定连接”，仍可能受消息总线环境波动影响。</td>
<td>连接状态更直观（连上&#x2F;断开&#x2F;重连），一般由插件自己做重连策略与超时。</td>
</tr>
<tr>
<td>蓝图&#x2F;代码使用差异（以你的工程为例）</td>
<td>典型流程：Finder 获取 Provider 列表 (&#x3D;&#x3D;可发现) → 选择 Provider → 创建对应 Source。</td>
<td>典型流程：直接调用 ConnectCapturyLiveLinkSource(IpAddress, bUseTCP, …) 建立 Source。<br/>这里 meta&#x3D;(Latent, … Duration&#x3D;”0.2”) 表示这是一个延迟&#x2F;等待式蓝图调用，Duration 用作等待&#x2F;超时窗口一类的参数（具体行为由实现决定），但它不是“局域网发现”。</td>
</tr>
</tbody></table>


            <!-- Tags -->
            


<div class="tags">
    <a href="/tags/Captury/">Captury</a> <a href="/tags/动作捕捉/">动作捕捉</a>
</div>



            <!-- Comments -->
            <div>
                




            </div>
        </div><!-- end content -->
    </section>

    <!-- Table of Contents will be generated by toc-collapse.js -->

</section><!-- end main -->

<!-- After footer scripts -->

<!-- 加载打包后的模块化代码 -->

<script src="/dist/js/main.js"></script>


<!-- 保留原有的 toc-collapse.js 直到完全重构 -->

<script src="/js/toc-collapse.js"></script>


<!-- Language Switcher -->

<script src="/js/i18n-data.js"></script>


<script src="/js/language-switcher.js"></script>


<!-- 第三方库 (CDN) -->
<!-- Mermaid -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<!-- Featherlight (图库) -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Mermaid 初始化 -->
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function() {
  if (typeof mermaid !== 'undefined') {
    mermaid.initialize({
      startOnLoad: false,
      theme: 'default',
      securityLevel: 'loose'
    });

    // Find and process mermaid code blocks
    const codeBlocks = document.querySelectorAll('figure.highlight.plaintext .code');

    codeBlocks.forEach((codeElement, index) => {
      let code = codeElement.textContent || codeElement.innerText;

      // Check if it's a mermaid diagram
      if (code.trim().match(/^(graph|flowchart|sequenceDiagram|classDiagram|stateDiagram|journey|pie|gitgraph|erDiagram)/)) {
        code = code.trim().replace(/^\s+|\s+$/g, '');

        const mermaidDiv = document.createElement('div');
        mermaidDiv.className = 'mermaid';
        mermaidDiv.textContent = code;
        mermaidDiv.id = 'mermaid-diagram-' + index;

        const figureElement = codeElement.closest('figure');
        if (figureElement) {
          figureElement.parentNode.replaceChild(mermaidDiv, figureElement);
        }
      }
    });

    setTimeout(() => {
      mermaid.init(undefined, document.querySelectorAll('.mermaid'));
    }, 100);
  }
});
</script>

<!-- ShaderToy Placeholder Processing -->
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(function() {
    const elements = document.querySelectorAll('.shadertoy-placeholder[data-id]');

    elements.forEach(element => {
      const shaderID = element.getAttribute('data-id');

      if (shaderID) {
        const container = document.createElement('div');
        container.style.cssText = `
          position: relative;
          width: 100%;
          height: 400px;
          margin: 20px 0;
          border: 2px solid #bfbbbb;
          border-radius: 8px;
          overflow: hidden;
          background-color: #f6f6f6;
        `;

        const iframe = document.createElement('iframe');
        iframe.src = \`https://www.shadertoy.com/embed/\${shaderID}?gui=true&t=10&paused=false&muted=false\`;
        iframe.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border: none;
        `;
        iframe.allowFullscreen = true;
        iframe.loading = 'lazy';

        container.appendChild(iframe);
        element.parentNode.insertBefore(container, element);
        element.parentNode.removeChild(element);
      }
    });
  }, 1000);
});
</script>

<!-- Disqus Comments -->


<!-- Google Analytics -->



</body>

</html>